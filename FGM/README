
Step 1: sorting suffixes of BA starting in B
============================================
  We assume we have the previous block in memory, we call it A' and assume it
  Now we read B into memory. In addition, we read from the disk the gt
  bitvector corresponding to the A' (which was computed during the scanning of
  the previous phase).
  
  We start by computing the gt_eof bitmap of length |B|, where gt_eof[i] == 1
  iff the suffix of BA starting in B is lex-larger than A. In old FGM this is
  accomplished using the KMP. We, instead, use the suffix ranking, variant with
  the available output. In total we need two strings and two bitmaps of length
  at most |B| (even if bitmaps are stored using chars this is <= 4|B| bytes).
  
  After this, we drop A' and gt_A, and remap the symbols in B. Then we drop
  gt_eof and are only left with remapped B. Then we run divsufsort to compute
  SA (peak: 5n bytes). Upon the divsufsort completion, we have the sorted
  sequence of suffixes of BA starting in A, which is the input the the second
  phase.

Step 2: computing the gap array/streaming
=========================================
  At this point we have the sorted order of suffixes of BA that start in B.
  First, we write this partial SA to disk (it is required for merging). At this
  point we also store to disk the prefix of gt array resulting from this
  iteration. Normally, this is done by continuing the backward search into B,
  but this is much faster.
  
  The goal of this phase is to compute the gap array. First, we replace the
  partial SA with the BWT and build rank data structure on top of it. The
  allowed space for the rank data structure is 4n bytes, thus have n bytes of
  space left. This is used to keep the gap array, which consits of n bytes and
  an std::vector for the big values (every time we increment gap[i] equal to 255
  (which becomes 0), we push_back i to this vector). After we're done with
  computing the gap array -- we save it to disk using the v-byte encoding.

--------------------------------------------------------------------------------
We repeat these steps until we have the gap array and partial SA on disk for
every block. Then follows Step 3: merging, which is relatively easy and does not
involve much memory management, only few buffers.
--------------------------------------------------------------------------------
